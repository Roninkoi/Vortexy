\documentclass[12pt]{article}
\usepackage[dvips]{graphicx}
\usepackage{color}
\usepackage[finnish, english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{titling}
\usepackage[top=52pt, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage{authblk}
\usepackage{comment}
\usepackage[linesnumbered,ruled]{algorithm2e}

\pagestyle{fancy}

\title {
  Vortexy fluid simulator
}

\date{\today}

\def \firstauth{
  Roni Koitermaa
}

\def \email{roninkoi@iki.fi}

\author[1] {
  \firstauth\thanks{\href{mailto: \email}{\email}}
}

\fancyhf{}
\setlength{\headheight}{15pt}
\lhead{\thetitle}
\rhead{\firstauth}
\cfoot{\thepage}

\renewcommand\maketitlehooka{\vspace{0.2\textheight}}
% \renewcommand\maketitlehookd{\vfill}

% CUSTOM COMMANDS
% characters
% \newcommand{\tmu}{\ensuremath{\mu}}
% math
\newcommand{\eint}[2]{\mathrel{ \substack{#2\\ \bigg /\\ #1}}}
\newcommand{\D}{\text{d}}
\newcommand{\BD}{\text{D}}
\newcommand{\I}{\text{i}}
\newcommand{\mln}{\overline{\ln}}
\newcommand{\Ln}{\text{Ln}}
\newcommand{\Arg}{\text{Arg}}
\newcommand{\Res}{\text{Res}}
\newcommand{\Ind}{\text{Ind}}
\newcommand{\lb}{\left(}
  \newcommand{\rb}{\right)}
\newcommand{\Imag}{\text{Im} \ }
\newcommand{\Real}{\text{Re} \ }
\newcommand{\ft}{\mathcal{F}}
\newcommand{\lt}{\mathcal{L}}
\newcommand{\pe}{\mathrel{+}=}
\newcommand{\te}{\mathrel{+}=}
% units
\newcommand{\us}[1]{ \ \text{#1}}
\newcommand{\un}[1]{ \text{#1}}
\newcommand{\up}[2]{\text{#1}^{#2}} % unit power
\newcommand{\uf}[2]{ \ \frac{\text{#1}}{\text{#2}}} % fraction of units
\newcommand{\mic}{$\upmu$}
\newcommand{\degc}{ \ ^\circ\text{C}}
\newcommand{\degs}{^\circ}
\newcommand{\es}{\text{e}}
\newcommand{\tp}[1]{ \times 10^{#1}}
\newcommand{\vb}[1]{\text{\textbf{#1}}}

\newcommand{\x}{\text}

\begin{document}

\setlength{\belowcaptionskip}{10pt}

\selectlanguage{english}

\normalsize

\begin{titlingpage}
  \maketitle

  % \begin{abstract}
  % \end{abstract}
  \begin{center}
    Software documentation
  \end{center}
\end{titlingpage}

\newpage

\tableofcontents

\newpage

\section{Introduction}

{\bf Vortexy} is a computational fluid dynamics (CFD) simulation code. It is written in C and uses the finite volume method with the SIMPLE algorithm to calculate flow of incompressible fluids, namely liquids.

The simulator is based on irregular tetrahedral meshes. These meshes can be computed from surfaces using the program Tetgen. The simulator takes a configuration file as input that contains paths to the simulation mesh and boundary conditions in addition to other settings. The state of the system is periodically written to an output file specified in the config. Included is also a renderer that uses OpenGL to visualize results.

\section{Background}

\subsection{Navier-Stokes equations}

\noindent

The Navier-Stokes equations form the basis for all of fluid dynamics. The momentum equation is typically written as \cite[p.~59]{tri}

\begin{equation}
  \frac{\partial \vb u}{\partial t} + (\vb u \cdot \nabla) \vb u = -\frac{1}{\rho} \nabla p + \nu \nabla^2 \vb u + g,
\end{equation}

where $\vb u = (u, v, w)$ is velocity in $\un{m} \ \up{s}{-1}$, t time in $\un{s}$, $\rho$ density in $\un{kg} \ \up{m}{-3}$, $p$ pressure in $\un{Pa}$, $\nu=\frac{\mu}{\rho}$ kinematic viscosity in $\up{m}{2} \ \up{s}{-1}$, $g$ gravity in $\un{m} \ \up{s}{-2}$.

The continuity equation must be satisfied for incompressible fluids that have no sinks of sources

\begin{equation}
  \nabla \cdot \vb u = 0,
\end{equation}

where $\vb u = (u, v, w)$ is velocity in $\un{m} \ \up{s}{-1}$.

\subsection{Turbulence}

\noindent

A simple way of predicting onset of turbulence is the Reynolds number \cite{tri}:

$$
\text{Re} = \frac{\mu u L}{\rho} = \frac{u L}{\nu}
$$

Turbulence models in simulations include RANS (Reynolds Averaged), LES (Large Eddy) and DNS (Direct).

\subsection{Finite volume method}

The \textit{finite volume method} (FVM) is based on a simulation mesh with volume elements. This enables evaluation of partial differential equations (PDEs) prevalent in physics. The divergence theorem allows us to convert volume integrals to surface integrals

$$
\int_V \nabla \cdot \vb F \ \D V = \oint_S \vb F \cdot \D \vb S,
$$

\noindent
so volume terms can be computed from fluxes at element faces.

\subsection{SIMPLE algorithm}

The SIMPLE algorithm solves the Navier-Stokes equations using an iterative procedure. First the momentum equation is solved, producing a momentum-conserving field $u^*$. However, this resultant field is not necessarily divergence free, meaning it does not satisfy the continuity equation. The SIMPLE algorithm solves this by calculating a correction $u'$ to the intermediate field by solving the \textit{pressure equation}. The pressure equation is derived from the continuity equation.

The SIMPLE algorithm can be summarized as follows \cite{mou, cws}:

\begin{enumerate}
\item Set boundary conditions, set $u$ and $p$
\item Compute gradients $\nabla u$ and $\nabla p$
\item Compute mass fluxes $j_m$, flow rate $\dot m = j_m \cdot A$
\item Solve \textit{momentum equation} using velocity guess $u^0$
\item Solve \textit{pressure correction equation} to get $p'$
\item Correct pressure $p = p^* + p'$ and velocity $v = v^* + v'$
\item Increment time $t^{n+1} = t^n + \Delta t$
\item Repeat
\end{enumerate}

\subsection{Discretization}

\noindent

The momentum equation is written in a form conducive for discretization \cite{mou}:
$$
\frac{\partial \vb u}{\partial t} + \nabla \cdot (\vb u \otimes \vb u) = - \frac{\nabla p}{\rho} + \frac{\mu}{\rho} \nabla \cdot (\nabla u) + \nabla \cdot (\nabla u)^T + \vb f_b
$$
$$
\vb{transient} + \vb{convective} =  \vb{diffusive} + \vb{sources}
$$

Continuity equation:
$$
\nabla \cdot \vb u = 0
$$

This saddle-point problem can be represented in matrix form as \cite{mou, qs}:

$$
A \vb u = \begin{pmatrix}
  F & B^T \\
  B & 0
\end{pmatrix}
\begin{pmatrix}
  \vb u \\
  p
\end{pmatrix} =
\begin{pmatrix}
  \vb f_b \\
  0
\end{pmatrix}
$$

Discretization for the one-dimensional momentum equation \cite{mou}:

\begin{equation}
  a_v u_v + \sum_{f \in f_{nb}} a_f u_f = b_v,
\end{equation}

where $a_v$ refers to a volume element and $a_f$ to a face element coefficient. This can be represented in matrix form as:

$$
\begin{pmatrix}
  a_{00} & a_{01} & 0 & \dots & 0 \\
  \vdots & \ddots & &  & \vdots \\
  a_f & a_f & a_v & a_f & a_f \\
  \vdots & &  & \ddots & \vdots \\
  0 & \dots & 0 & a_{n (n - 1)} & a_{nn}
\end{pmatrix}
\begin{pmatrix}
  u_0 \\
  \vdots \\
  u_n
\end{pmatrix} =
\begin{pmatrix}
  b_{0} \\
  \vdots \\
  b_n
\end{pmatrix},
$$

where $u_0 \dots u_n$ represents volume element velocities. In the pressure calculation these are referred to as $u^*$, i.e. momentum conserving. The coefficients $a$ and $b$ are calculated for each volume element and assembled into a matrix. Components X, Y and Z are calculated one after another.\\

Face fluxes:
\begin{align}
  \phi_f = \max(\dot m_f, 0) + \mu \frac{E_f}{d_{vf}} \\
  \Phi_f = -\max(-\dot m_f, 0) - \mu \frac{E_f}{d_{vf}} \\
  \vec \psi_f = - \mu (\nabla \vb u_f) \cdot \vb T_f + \dot m_f (\vb u_f^{\text{hr}} - \vb u_f^{\text{uw}}),
\end{align}
where $\vb S_f = A_f \hat n_f = \vb E_f + \vb T_f$ and $\dot m_f = \rho \vb u_f \cdot \vb S_f$. High-resolution model velocity $\vb u_f^{\text{hr}} = \vb u_f^{\text{uw}}$.\\

Volume fluxes:
\begin{align}
  \phi_v = \frac{\rho V}{\Delta t} \\
  \vec \psi_v = \frac{\rho V}{\Delta t} \vb u_v - \vb f_b V
\end{align}

Coefficients:
\begin{align}
  a_v = \phi_v + \sum_{f \in f_{nb}} \phi_f = \frac{\rho V}{\Delta t} + \sum_{f \in f_{nb}} \lb \max(\dot m_f, 0) + \mu \frac{E_f}{d_{vf}} \rb \\
  a_f = \Phi_f = -\max(-\dot m_f, 0) - \mu \frac{E_f}{d_{vf}}
\end{align}
\begin{equation}
  \vb b_v = -\vec \psi_v - \sum_{f \in f_{nb}} \vec \psi_f + \sum_{f \in f_{nb}} \lb \mu (\nabla \vb u_f)^T \cdot \vb S_f \rb - V \nabla p_v
\end{equation}
$$
= - \frac{\rho V}{\Delta t} \vb u_v - \vb f_b V - \sum_{f \in f_{nb}} \lb - \mu (\nabla \vb u_f) \cdot \vb T_f + \dot m_f (\vb u_f - \vb u_f^{\text{uw}}) \rb + \sum_{f \in f_{nb}} \lb \mu (\nabla \vb u_f)^T \cdot \vb S_f \rb - V \nabla p_v
$$

$$
\vb D_v = \frac{V}{a_v}
$$

Intermediate momentum equation:

\begin{equation}
  u_v^* + \sum_{f \in f_{nb}} \frac{a_f}{a_c} \vb u_f^* = -\frac{V}{a_v} \nabla p_v + \frac{b_v + V \nabla p_v}{a_v}
\end{equation}

Similarly, the pressure correction equation can be discretized \cite{mou}:

\begin{equation}
  a_v p_v' + \sum_{f \in f_{nb}} a_f p_f' = b_v
\end{equation}

With coefficients:

\begin{align}
  a_f = -\rho \mathcal{D}_f \\
  a_v = \sum_{f \in f_{nb}} \rho \mathcal{D}_f\\
  b_v = - \sum_{f \in f_{nb}} \dot m_f^* = - \sum_{f \in f_{nb}} \rho \vb u_f^* \cdot \vb S_f,
\end{align}
where $\mathcal{D}_f$ is calculated using the minimum correction approach:

$$
\mathcal{D}_f = \frac{d_{vf}^x S_f^x \overline{D_f^x} + d_{vf}^y S_f^y \overline{D_f^y} + d_{vf}^z S_f^z \overline{D_f^z}}{(d_{vf}^x)^2 + (d_{vf}^y)^2 + (d_{vf}^z)^2}.
$$



All of these are $n \times n$ diagonally dominant matrices which can be solved using a numerical matrix solver, such as Gauss-Seidel. The off-diagonal coefficients represent neighbouring elements, so they will be mostly zero.

\subsection{Gauss-Seidel method}

The Gauss-Seidel method is an iterative procedure to solve a linear system of equations. It belongs to a class of successive over-relaxation methods (SOR). The linear system is represented as a diagonally dominant square matrix $A$ and given a vector $\vb b$ the solution vector $\vb x$ to the equation
$$
A \vb x = \vb b
$$
is found by an iterative algorithm. GS has better efficiency for large systems than other methods such as matrix inversion.

The iteration for the GS method can be defined as \cite[p.~510]{golub}:

\begin{equation}
  x_i^{(k + 1)} = \frac{b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k + 1)} - \sum_{j=i+1}^{n} a_{ij} x_j^{(k)}}{a_{ii}}
\end{equation}

In the simulator the GS solver is implemented thusly:

\begin{algorithm}[H]
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \underline{function GaussSeidel} $(A, b, m, \varepsilon)$

  \Input{$N \times N$ matrix $A$, $N$-vector $\vb b$, maximum iteration count $m$ and convergence criterion $\varepsilon$}
  \Output{Solution $N$-vector $x$}

  \For{$k \in [0, m[$} {
    $\delta = 0$
    
    \For{$i \in [0, N[$} {
      $s_0 = \frac{1}{A_{ii}}$

      $s_1 = 0$
      
      \For{$j \in [0, i - 1]$} {
        $s_1 \pe A_{ij} x_{j}$
      }
      
      $s_2 = 0$
      
      \For{$j \in [i + 1, N[$} {
        $s_2 \pe A_{ij} x_{j}$
      }

      $s_0 \te b_{i} - s_1 - s_2$

      $\delta \pe x_{i} - s_0$

      $x_i = s_0$
    }

    \If{$|\delta| < \varepsilon$} {
      break
    }
  }

  return x
  
  \caption{Gauss-Seidel method}
\end{algorithm}

\subsection{Boundary conditions}

\indent

\begin{table}[H]
  \centering
  \begin{tabular}{| l | l |}
    \hline
    
    Type & Specified quantity \\
    
    \hline
    
    No-slip wall & $u$ \\

    \hline

    Slip wall & $u$ \\
    
    \hline

    Inlet & $u$ or $p$ \\
    
    \hline

    Outlet & $\dot m$ or $p$\\
    
    \hline
  \end{tabular}
  
  \caption{Four main types of boundary conditions}
\end{table}

\section{Implementation}

\subsection{Simulation mesh}

Irregular, non-orthogonal Delaunay tetrahedralization

\subsection{Solver}

Gauss-Seidel with some sparse matrix optimizations

\subsection{Rendering}

OpenGL 3.1, GLSL 150

\section{Software}

\subsection{Compilation}

The software is compiled using CMake. The \verb|CMakeLists.txt| file is found in the root directory. There are two main ways to configure the simulator: with rendering and without. This is achieved by passing the \verb|-DSIMONLY=ON| flag to CMake. The non-graphical version is linked entirely statically. The graphical version has its \verb|RPATH| set to \verb|./lib/|, so required dynamically linked libraries can be placed there.

The root directory contains shell scripts that can be used for compilation. To build the simulator, renderer and libraries use the script \verb|buildall.sh|. To build the simulator without the renderer use the script \verb|buildsim.h| and set \verb|RENDER_ENABLED| to 0 in \verb|sim.h|.\\

Dependencies: libc, libm, (OpenGL, GLEW, GLFW)\\

Building using default options:

\begin{verbatim}
  cmake .
  make
\end{verbatim}

\subsection{Configuration}

\subsubsection{Simulation config}

\begin{verbatim}
# simulator options
render 0 # use renderer
simulating 1 # start simulation right away
autoquit 1 # quit when not simulating
divhalt 0 # halt simulation upon divergence

fluid data/lid16/lid100.cfg # fluid config file
endt 0.15 # end time / sim duration
maxit 10000 # max solver iterations
epsilon 1.0e-6 # solver target
dtmaxit 15 # max time-step iterations
residual 5.0e0 # solution residual
transient 0 # include Chie-Chow transient term
gradit 2 # gradient iterations, if 0 -> first-order
relaxm 1.0 # relax mass flow

# IO options
file data/lid16/out100.dat # input/output file
printitn 1 # print time-step iteration number
outputting 1 # writing to output file?
outputt 0 # outputting time data
outputf 1 # frequency of output (1/cycle)
inputf 20 # frequency of input (1/cycle)
inputram 0 # bytes to load into memory, 0 for direct file access

# rendering options
# f  v  t  l  w  m
# 64 32 16 8  4  2
rmode 10 # rendering mode (see above)
rz -4.0 # camera z
rs 0.3 # render scale
bgcol 1.0 1.0 1.0 # background color

vs 1.0 # velocity scale (m/s)
ps 100000.0 # pressure scale (Pa)

end # optional
\end{verbatim}

\subsubsection{Fluid config}

\begin{verbatim}
mu 2.0e-1 # viscosity
rho 1.0e-1 # density

dt 0.001 # time step

vr 0.7 # velocity urf
pr 0.3 # pressure under-relaxation factor

mesh data/lid16/plane_16x16_s2.1.mesh

f 0.0 0.0 0.0

bp 1.0e3 # base pressure, p = bp + ip

ebc 1 # boundary condition for all edges

# bc <f id> <bc> = boundary condition
# 0 = open, 1 = no-slip wall, 2 = slip wall
# 3 = velocity inlet, 4 = pressure inlet
# 5 = mass flow outlet, 6 = pressure outlet
# iv <f id> <v> = initial velocity, ip <f id> <p> = initial pressure
# cv <f id> <v> = constant velocity, cp <f id> <p> = constant pressure

bc 244 3 # velocity inlet for face id 244
cv 244 10.0e2
iv 244 10.0e2

end # optional
\end{verbatim}

\subsection{Output data}

\begin{verbatim}
s <sim tick>
o <object id> t <time in s> f <face id> x <face centroid x in m> <y> <z> 
v <face velocity x in m/s> <y> <z> p <face pressure in Pa>
e
\end{verbatim}

\addcontentsline{toc}{section}{References}
\begin{thebibliography}{9}
  \bibitem{tri} D. J. Tritton. (1977). Physical Fluid Dynamics. Springer.
  
\bibitem{mou} F. Moukalled, L. Mangani \& M. Darwish. (2016). The Finite Volume Method in Computational Fluid Dynamics: An Advanced Introduction with OpenFOAM and Matlab. Fluid Mechanics and Its Applications Volume 113. Springer International Publishing, Cham. \url{https://doi.org/10.1007/978-3-319-16874-6}

  \bibitem{golub} G. H. Golub \& C. F. Van Loan. (1996). Matrix Computations. The John Hopkins University Press.
  
\bibitem{qs} \url{https://quickersim.com/tutorial/tutorial-2-numerics-simple-scheme/}
\bibitem{ofs} \url{https://www.openfoam.com/documentation/guides/latest/doc/guide-applications-solvers-simple.html}
\bibitem{cws} \url{https://www.cfd-online.com/Wiki/SIMPLE_algorithm}

\end{thebibliography}

\end{document}

% Local Variables:
% coding: utf-8-unix
% TeX-engine: luatex
% End:
